/**
 * ùó¶ùóòùó° Bot - ViewOnce Command (VV)
 * Version : DEFINITIVE - Bas√©e sur le code qui fonctionne
 */

import { downloadContentFromMessage } from '@whiskeysockets/baileys';
import configs from '../configs.js';
import chalk from 'chalk';

export async function viewOnceCommand(sock, chatId, message, args) {
    const jid = chatId;
    const msg = message;
    
    // R√©cup√©rer le JID du propri√©taire
    const ownerNumber = configs.ownerNumber.replace(/[^0-9]/g, '');
    const ownerJid = `${ownerNumber}@s.whatsapp.net`;
    
    const isGroup = jid.endsWith('@g.us');
    const sender = msg.key.participant || msg.key.remoteJid;

    // ‚úÖ 1. Extraire le message cit√©
    const quoted = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;
    
    if (!quoted) {
        return await sock.sendMessage(chatId, {
            text: '‚ùå Veuillez r√©pondre √† une image ou vid√©o en *Vue Unique*.'
        }, { quoted: msg });
    }

    // ‚úÖ 2. V√©rifier les 3 formats possibles
    const quotedImage = quoted.imageMessage;
    const quotedVideo = quoted.videoMessage;
    const quotedAudio = quoted.audioMessage;
    
    // Format viewOnceV2 ou viewOnceV1
    const viewOnceV2 = quoted.viewOnceMessageV2?.message;
    const viewOnceV1 = quoted.viewOnceMessage?.message;
    const viewOnceContainer = viewOnceV2 || viewOnceV1;

    // ‚úÖ 3. D√âTECTION : 2 formats possibles
    let mediaMessage = null;
    let mediaType = null;
    let isViewOnce = false;

    // FORMAT 1 : Vue unique classique (viewOnceMessage)
    if (viewOnceContainer) {
        if (viewOnceContainer.imageMessage) {
            mediaMessage = viewOnceContainer.imageMessage;
            mediaType = 'image';
            isViewOnce = true;
        } else if (viewOnceContainer.videoMessage) {
            mediaMessage = viewOnceContainer.videoMessage;
            mediaType = 'video';
            isViewOnce = true;
        } else if (viewOnceContainer.audioMessage) {
            mediaMessage = viewOnceContainer.audioMessage;
            mediaType = 'audio';
            isViewOnce = true;
        }
    }
    // FORMAT 2 : Vue unique d√©voil√©e (imageMessage.viewOnce = true)
    else if (quotedImage && quotedImage.viewOnce) {
        mediaMessage = quotedImage;
        mediaType = 'image';
        isViewOnce = true;
    } else if (quotedVideo && quotedVideo.viewOnce) {
        mediaMessage = quotedVideo;
        mediaType = 'video';
        isViewOnce = true;
    } else if (quotedAudio && quotedAudio.viewOnce) {
        mediaMessage = quotedAudio;
        mediaType = 'audio';
        isViewOnce = true;
    }

    if (!isViewOnce || !mediaMessage) {
        console.log(chalk.yellow('‚ö†Ô∏è Structure du message:'), JSON.stringify(quoted, null, 2));
        return await sock.sendMessage(chatId, {
            text: '‚ùå Ce message n\'est pas une vue unique valide.'
        }, { quoted: msg });
    }


    try {
        console.log(chalk.cyan(`üîç [VV] D√©voilement vue unique: ${mediaType.toUpperCase()}`));

        // ‚úÖ 4. T√©l√©charger le m√©dia
        const stream = await downloadContentFromMessage(mediaMessage, mediaType);
        let buffer = Buffer.from([]);
        
        for await (const chunk of stream) {
            buffer = Buffer.concat([buffer, chunk]);
        }
        
        if (buffer.length === 0) {
            throw new Error('Buffer vide - impossible de t√©l√©charger le m√©dia');
        }

        // ‚úÖ 5. Pr√©parer les infos contextuelles
        let contextInfo = '';
        
        if (isGroup) {
            try {
                const groupMetadata = await sock.groupMetadata(jid);
                const senderName = sender.split('@')[0];
                contextInfo = `üìç *Groupe:* ${groupMetadata.subject}\nüë§ *Exp√©diteur:* @${senderName}\n\n`;
            } catch (err) {
                const senderName = sender.split('@')[0];
                contextInfo = `üìç *Groupe:* ${jid.split('@')[0]}\nüë§ *Exp√©diteur:* @${senderName}\n\n`;
            }
        } else {
            const senderName = sender.split('@')[0];
            contextInfo = `> *Chat priv√© avec:* @${senderName}\n\n`;
        }

        const caption = `üîì *${mediaType.toUpperCase()} √† vue unique r√©v√©l√©${mediaType === 'image' ? 'e' : ''}*\n\n${contextInfo}${mediaMessage.caption ? `üìù *Caption:* ${mediaMessage.caption}` : ''}`;

        // ‚úÖ 6. Envoyer au propri√©taire
        if (mediaType === 'image') {
            await sock.sendMessage(ownerJid, {
                image: buffer,
                caption: caption,
                mentions: [sender]
            });
        } else if (mediaType === 'video') {
            await sock.sendMessage(ownerJid, {
                video: buffer,
                caption: caption,
                mentions: [sender]
            });
        } else if (mediaType === 'audio') {
            await sock.sendMessage(ownerJid, {
                text: caption,
                mentions: [sender]
            });
            await sock.sendMessage(ownerJid, {
                audio: buffer,
                mimetype: mediaMessage.mimetype || 'audio/mpeg',
                ptt: mediaMessage.ptt || false
            });
        }

        console.log(chalk.green(`‚úÖ [VV] ${mediaType} vue unique d√©voil√© (envoy√© au owner)`));
        
       

    } catch (error) {
        console.error(chalk.red(`‚ùå [VV] Erreur d√©voilement vue unique:`), error);
        
        let errorMessage = '‚ùå *Erreur d√©voilement vue unique*\n\n';
        
        if (error.message.includes('Buffer vide')) {
            errorMessage += '‚ö†Ô∏è Impossible de t√©l√©charger le m√©dia. Il est peut-√™tre expir√©.';
        } else if (error.message.includes('not found') || error.message.includes('404')) {
            errorMessage += '‚ö†Ô∏è Le m√©dia a expir√© et n\'est plus disponible sur les serveurs WhatsApp.';
        } else if (error.message.includes('download')) {
            errorMessage += '‚ö†Ô∏è √âchec du t√©l√©chargement du m√©dia.';
        } else if (error.message.includes('decryption')) {
            errorMessage += '‚ö†Ô∏è Impossible de d√©crypter le m√©dia. Il a peut-√™tre expir√©.';
        } else {
            errorMessage += `‚ö†Ô∏è ${error.message}`;
        }
        
        // Informations contextuelles
        if (isGroup) {
            try {
                const groupMetadata = await sock.groupMetadata(jid);
                errorMessage += `\n\n> Groupe: ${groupMetadata.subject}`;
            } catch (err) {
                errorMessage += `\n\n> Groupe: ${jid.split('@')[0]}`;
            }
        } else {
            errorMessage += `\n\n> Chat priv√©`;
        }
        
        // Erreur envoy√©e au propri√©taire
        await sock.sendMessage(ownerJid, {
            text: errorMessage
        });
        
        // Message d'erreur dans le chat
        await sock.sendMessage(chatId, { 
            text: '‚ùå Impossible de r√©cup√©rer le m√©dia. Il est peut-√™tre d√©j√† expir√©.' 
        }, { quoted: msg });
    }
}

export default { viewOnceCommand };