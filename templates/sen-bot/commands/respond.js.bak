/**
 * ğ—¦ğ—˜ğ—¡ Bot - Auto Respond Commands
 * Copyright (c) 2024 ğ™ğ™ğ™€ğ™‹ğ™ƒğ˜¿ğ™€ğ™‘
 */

import { downloadContentFromMessage } from '@whiskeysockets/baileys';
import { isOwner } from '../lib/authHelper.js';
import configs from '../configs.js';
import autoRespondManager from '../lib/autoRespondManager.js';

/**
 * Commande .respond on/off - Active/dÃ©sactive les rÃ©ponses automatiques
 */
export async function respondCommand(sock, chatId, message, args) {
    try {
        if (!await isOwner(sock, message, configs)) {
            return sock.sendMessage(chatId, { 
                text: 'âŒ Owner only command' 
            }, { quoted: message });
        }

        if (args.length === 0) {
            const status = autoRespondManager.isEnabled();
            return sock.sendMessage(chatId, {
                text: `â”â”â”ã€” AUTO RESPOND ã€•â”â”â”“\n\n` +
                      `Status: ${status ? 'âœ… ON' : 'âŒ OFF'}\n\n` +
                      `Usage:\n` +
                      `â”ƒ .respond on  - Enable\n` +
                      `â”ƒ .respond off - Disable\n` +
                      `â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›`
            }, { quoted: message });
        }

        const action = args[0].toLowerCase();
        
        if (action !== 'on' && action !== 'off') {
            return sock.sendMessage(chatId, {
                text: 'âŒ Invalid option. Use: .respond on or .respond off'
            }, { quoted: message });
        }

        const enabled = action === 'on';
        autoRespondManager.setEnabled(enabled);

        await sock.sendMessage(chatId, {
            text: `âœ… Auto respond ${enabled ? 'ENABLED' : 'DISABLED'}`
        }, { quoted: message });

    } catch (error) {
        console.error('Respond Error:', error);
        await sock.sendMessage(chatId, {
            text: 'âŒ Error updating auto respond'
        }, { quoted: message });
    }
}

/**
 * Commande .setrespond - DÃ©finir le message de rÃ©ponse
 */
export async function setrespondCommand(sock, chatId, message, args) {
    try {
        if (!await isOwner(sock, message, configs)) {
            return sock.sendMessage(chatId, { 
                text: 'âŒ Owner only command' 
            }, { quoted: message });
        }

        const quoted = message.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        
        if (!quoted) {
            return sock.sendMessage(chatId, {
                text: 'âš ï¸ Reply to a message (text, image, video, audio, sticker, or video note)\n\n' +
                      'Examples:\n' +
                      'â”ƒ Reply to text: .setrespond\n' +
                      'â”ƒ Reply to image: .setrespond\n' +
                      'â”ƒ Reply to video: .setrespond\n' +
                      'â”ƒ Reply to audio: .setrespond\n' +
                      'â”ƒ Reply to sticker: .setrespond\n' +
                      'â”ƒ Reply to video note: .setrespond'
            }, { quoted: message });
        }

        await sock.sendMessage(chatId, { 
            react: { text: 'ğŸ’¾', key: message.key }
        });

        let responseData = {
            type: null,
            content: null,
            caption: null
        };

        // --- TEXT ---
        if (quoted.conversation || quoted.extendedTextMessage?.text) {
            responseData.type = 'text';
            responseData.content = quoted.conversation || quoted.extendedTextMessage.text;
        }
        // --- IMAGE ---
        else if (quoted.imageMessage) {
            const stream = await downloadContentFromMessage(quoted.imageMessage, 'image');
            let buffer = Buffer.from([]);
            for await (const chunk of stream) {
                buffer = Buffer.concat([buffer, chunk]);
            }
            
            responseData.type = 'image';
            responseData.content = buffer.toString('base64');
            responseData.caption = quoted.imageMessage.caption || '';
        }
        // --- VIDEO NOTE (PTV) - DOIT ÃŠTRE AVANT VIDEO NORMAL ---
        else if (quoted.videoMessage?.ptv) {
            const stream = await downloadContentFromMessage(quoted.videoMessage, 'video');
            let buffer = Buffer.from([]);
            for await (const chunk of stream) {
                buffer = Buffer.concat([buffer, chunk]);
            }
            
            responseData.type = 'video';
            responseData.content = buffer.toString('base64');
            responseData.ptv = true; // VidÃ©o circulaire
            responseData.caption = '';
        }
        // --- VIDEO ---
        else if (quoted.videoMessage) {
            const stream = await downloadContentFromMessage(quoted.videoMessage, 'video');
            let buffer = Buffer.from([]);
            for await (const chunk of stream) {
                buffer = Buffer.concat([buffer, chunk]);
            }
            
            responseData.type = 'video';
            responseData.content = buffer.toString('base64');
            responseData.caption = quoted.videoMessage.caption || '';
            responseData.ptv = false; // VidÃ©o normale
        }
        // --- AUDIO ---
        else if (quoted.audioMessage) {
            const stream = await downloadContentFromMessage(quoted.audioMessage, 'audio');
            let buffer = Buffer.from([]);
            for await (const chunk of stream) {
                buffer = Buffer.concat([buffer, chunk]);
            }
            
            responseData.type = 'audio';
            responseData.content = buffer.toString('base64');
            responseData.ptt = quoted.audioMessage.ptt || false;
        }
        // --- STICKER ---
        else if (quoted.stickerMessage) {
            const stream = await downloadContentFromMessage(quoted.stickerMessage, 'sticker');
            let buffer = Buffer.from([]);
            for await (const chunk of stream) {
                buffer = Buffer.concat([buffer, chunk]);
            }
            
            responseData.type = 'sticker';
            responseData.content = buffer.toString('base64');
        }
        else {
            return sock.sendMessage(chatId, {
                text: 'âŒ Unsupported message type'
            }, { quoted: message });
        }

        // Sauvegarder
        autoRespondManager.setResponse(responseData);

        await sock.sendMessage(chatId, {
            text: `âœ… *AUTO RESPOND SET*\n\n` +
                  `Type: ${responseData.type.toUpperCase()}\n\n` +
                  `This message will be sent when you are mentioned in a group.`
        }, { quoted: message });

    } catch (error) {
        console.error('SetRespond Error:', error);
        await sock.sendMessage(chatId, {
            text: 'âŒ Error setting auto respond'
        }, { quoted: message });
    }
}

/**
 * Commande .clearrespond - Supprimer le message de rÃ©ponse
 */
export async function clearrespondCommand(sock, chatId, message, args) {
    try {
        if (!await isOwner(sock, message, configs)) {
            return sock.sendMessage(chatId, { 
                text: 'âŒ Owner only command' 
            }, { quoted: message });
        }

        autoRespondManager.clearResponse();

        await sock.sendMessage(chatId, {
            text: 'âœ… Auto respond message cleared'
        }, { quoted: message });

    } catch (error) {
        console.error('ClearRespond Error:', error);
        await sock.sendMessage(chatId, {
            text: 'âŒ Error clearing auto respond'
        }, { quoted: message });
    }
}

export default { 
    respondCommand, 
    setrespondCommand,
    clearrespondCommand 
};