/**
 * ð—¦ð—˜ð—¡ Bot - Auto Presence Manager
 * GÃ¨re les Ã©tats "recording" et "typing"
 */

import fs from 'fs';
import path from 'path';

const PRESENCE_FILE = './data/autopresence.json';

class AutoPresenceManager {
    constructor() {
        this.config = {
            recording: false,
            typing: false
        };
        this.intervals = {
            recording: null,
            typing: null
        };
        this.ensureFile();
        this.loadConfig();
    }

    ensureFile() {
        const dir = path.dirname(PRESENCE_FILE);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
        if (!fs.existsSync(PRESENCE_FILE)) {
            fs.writeFileSync(PRESENCE_FILE, JSON.stringify(this.config, null, 2));
        }
    }

    loadConfig() {
        try {
            const data = JSON.parse(fs.readFileSync(PRESENCE_FILE, 'utf-8'));
            this.config = { ...this.config, ...data };
        } catch (error) {
            console.error('Error loading autopresence config:', error);
        }
    }

    saveConfig() {
        try {
            fs.writeFileSync(PRESENCE_FILE, JSON.stringify(this.config, null, 2));
        } catch (error) {
            console.error('Error saving autopresence config:', error);
        }
    }

    /**
     * Active/dÃ©sactive l'Ã©tat "recording"
     */
    setRecording(enabled, sock) {
        this.config.recording = enabled;
        this.saveConfig();

        // ArrÃªter l'ancien intervalle
        if (this.intervals.recording) {
            clearInterval(this.intervals.recording);
            this.intervals.recording = null;
        }

        // Si activÃ©, crÃ©er un nouvel intervalle
        if (enabled && sock) {
            this.intervals.recording = setInterval(async () => {
                try {
                    // Envoyer l'Ã©tat "recording" Ã  tous les chats actifs
                    await sock.sendPresenceUpdate('recording', null);
                } catch (error) {
                    console.error('Error sending recording presence:', error);
                }
            }, 10000); // Toutes les 10 secondes
        }
    }

    /**
     * Active/dÃ©sactive l'Ã©tat "typing"
     */
    setTyping(enabled, sock) {
        this.config.typing = enabled;
        this.saveConfig();

        // ArrÃªter l'ancien intervalle
        if (this.intervals.typing) {
            clearInterval(this.intervals.typing);
            this.intervals.typing = null;
        }

        // Si activÃ©, crÃ©er un nouvel intervalle
        if (enabled && sock) {
            this.intervals.typing = setInterval(async () => {
                try {
                    // Envoyer l'Ã©tat "composing" (typing) Ã  tous les chats actifs
                    await sock.sendPresenceUpdate('composing', null);
                } catch (error) {
                    console.error('Error sending typing presence:', error);
                }
            }, 10000); // Toutes les 10 secondes
        }
    }

    /**
     * Restaurer les Ã©tats au dÃ©marrage du bot
     */
    restore(sock) {
        if (this.config.recording) {
            this.setRecording(true, sock);
        }
        if (this.config.typing) {
            this.setTyping(true, sock);
        }
    }

    /**
     * Envoyer la prÃ©sence pour un chat spÃ©cifique (utilisÃ© lors d'un message reÃ§u)
     * Mode "smart" : n'envoie la prÃ©sence que si ce n'est pas une commande
     */
    async sendPresenceForChat(sock, chatId, messageText = '', isCommand = false) {
        try {
            // Ne pas envoyer de prÃ©sence si c'est une commande
            if (isCommand) {
                // Envoyer "available" pour annuler toute prÃ©sence en cours
                await sock.sendPresenceUpdate('available', chatId);
                return;
            }

            // Envoyer la prÃ©sence configurÃ©e seulement si ce n'est pas une commande
            if (this.config.recording) {
                await sock.sendPresenceUpdate('recording', chatId);
            } else if (this.config.typing) {
                await sock.sendPresenceUpdate('composing', chatId);
            }
        } catch (error) {
            console.error('Error sending presence for chat:', error);
        }
    }

    /**
     * RÃ©initialiser la prÃ©sence (remettre Ã  "available")
     */
    async resetPresence(sock, chatId) {
        try {
            await sock.sendPresenceUpdate('available', chatId);
        } catch (error) {
            console.error('Error resetting presence:', error);
        }
    }

    /**
     * Envoyer une prÃ©sence temporaire (pour simuler une action rÃ©elle)
     */
    async sendTemporaryPresence(sock, chatId, type, duration = 3000) {
        try {
            await sock.sendPresenceUpdate(type, chatId);
            
            // Remettre Ã  la prÃ©sence par dÃ©faut aprÃ¨s la durÃ©e
            setTimeout(async () => {
                if (this.config.recording) {
                    await sock.sendPresenceUpdate('recording', chatId);
                } else if (this.config.typing) {
                    await sock.sendPresenceUpdate('composing', chatId);
                } else {
                    await sock.sendPresenceUpdate('available', chatId);
                }
            }, duration);
        } catch (error) {
            console.error('Error sending temporary presence:', error);
        }
    }

    isRecordingEnabled() {
        return this.config.recording;
    }

    isTypingEnabled() {
        return this.config.typing;
    }
}

export default new AutoPresenceManager();